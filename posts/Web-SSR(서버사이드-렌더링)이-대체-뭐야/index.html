<!DOCTYPE html><html lang="ko-KR" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="day-prompt" content="d ago"><meta name="hour-prompt" content="hr ago"><meta name="minute-prompt" content="min ago"><meta name="justnow-prompt" content="just now"><meta name="generator" content="Jekyll v4.2.0" /><meta property="og:title" content="[Web] SSR(서버사이드 렌더링)이 대체 뭐야?" /><meta property="og:locale" content="ko_KR" /><meta name="description" content="Server Side Rendering (SSR) : 서버 측 렌더링 이란 ?" /><meta property="og:description" content="Server Side Rendering (SSR) : 서버 측 렌더링 이란 ?" /><link rel="canonical" href="/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/" /><meta property="og:url" content="/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/" /><meta property="og:site_name" content="머리속에 다 있어요" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-09-15T00:00:00+09:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="[Web] SSR(서버사이드 렌더링)이 대체 뭐야?" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"description":"Server Side Rendering (SSR) : 서버 측 렌더링 이란 ?","url":"/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/","@type":"BlogPosting","headline":"[Web] SSR(서버사이드 렌더링)이 대체 뭐야?","dateModified":"2021-09-17T11:09:10+09:00","datePublished":"2021-09-15T00:00:00+09:00","mainEntityOfPage":{"@type":"WebPage","@id":"/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/"},"@context":"https://schema.org"}</script><title>[Web] SSR(서버사이드 렌더링)이 대체 뭐야? | 머리속에 다 있어요</title><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/site.webmanifest"><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico"><meta name="apple-mobile-web-app-title" content="머리속에 다 있어요"><meta name="application-name" content="머리속에 다 있어요"><meta name="msapplication-TileColor" content="#da532c"><meta name="msapplication-config" content="/assets/img/favicons/browserconfig.xml"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="https://cdn.jsdelivr.net"><link rel="dns-prefetch" href="https://cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/magnific-popup@1.1.0/dist/magnific-popup.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end" lang=""><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/img/site/profile.jpeg" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">머리속에 다 있어요</a></div><div class="site-subtitle font-italic">아닐걸?</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/categories/" class="nav-link"> <i class="fa-fw fas fa-stream ml-xl-3 mr-xl-3 unloaded"></i> <span>CATEGORIES</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>ABOUT</span> </a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/jaeone94" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['jaeone.prt','gmail.com'].join('@')" aria-label="email" class="order-4" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-5" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/"> Home </a> </span> <span>[Web] SSR(서버사이드 렌더링)이 대체 뭐야?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" autocomplete="off" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>[Web] SSR(서버사이드 렌더링)이 대체 뭐야?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Jaeone94 </span> on <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 15, 2021, 12:00 AM +0900" >Sep 15<i class="unloaded">2021-09-15T00:00:00+09:00</i> </span></div><div> <span> Updated <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Sep 17, 2021, 11:09 AM +0900" >Sep 17<i class="unloaded">2021-09-17T11:09:10+09:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3867 words">21 min read</span></div></div><div class="post-content"><h2 id="server-side-rendering-ssr--서버-측-렌더링-이란-">Server Side Rendering (SSR) : 서버 측 렌더링 이란 ?</h2><p><strong>서버사이드 렌더링(일명 SSR)</strong>은 서버가 클라이언트에게 HTML 파일을 전달할 때, 사용자가 볼 수 있는 완전한 html을 전송한다는 뜻이다.</p><p>즉, 클라이언트가 서버에게 요청신호를 보내면, 클라이언트의 웹 브라우저가 페이지를 그리기 위해 별도의 작업을 할 필요 없이 완전히 구성된 페이지(html)를 클라이언트에게 돌려주는 것이다.</p><p>SSR 에 대한 정의는 아주 심플하지만, 정확하게 감이 잘 오질 않는다. 용어 정리부터 다시 해보자.</p><h2 id="렌더링rendering-이란-">렌더링(Rendering) 이란 ?</h2><p>웹 개발에서의 렌더링은 웹 사이트 코드를 사용자가 웹 사이트를 방문할 때 보게 되는 실제 대화형 페이지로 바꾸는 프로세스다. (코드 -&gt; 페이지)</p><p>이 용어는 일반적으로 HTML, CSS 및 JavaScript 코드의 사용을 나타낸다.</p><p>이 렌더링이란 프로세스는 일반적으로 웹 브라우저에서 사용되는 렌더링 엔진에 의해 수행되는데. 웹 브라우저와 밀접하게 연관되어 있어 렌더링 엔진을 일반적으로 브라우저 엔진이라고 말하기도 한다. (실제론 별개의 개념이지만 일반적으로 얘기하기도 한다)</p><h2 id="브라우저-렌더링-프로세스의-순서">브라우저 렌더링 프로세스의 순서</h2><p>브라우저가 사용자에게 렌더링된 페이지를 제공하는 순서이다.</p><h3 id="원시-데이터를-dom과-cssom으로">원시 데이터를 DOM과 CSSOM으로</h3><ol><li><p>웹 서버가 HTML, CSS 및 JavaScript가 포함된 파일 폴더를 사용자의 웹 브라우저로 전송 (웹서버 -&gt; 브라우저 전송)</p><li><p>브라우저 엔진이 전송받은 데이터(Byte)를 문자(HTML 코드)로 변환 (Byte -&gt; 문자열 Code)</p><li><p>코드 문자열( HTML Code )을 토큰으로 구문분석 + 토큰을 노드로 구문분석 (HTML 문자열 Code -&gt; 토큰 -&gt; 노드)</p><li><p>노드를 DOM(문서 객체 모델) Tree로 표현 + 동시에 CSS 코드는 CSSOM(CSS 객체모델)로 변환. (노드 -&gt; DOM Tree, Css 코드 -&gt; CSSOM)</p><blockquote><p>DOM ? HTML, XML 문서의 프로그래밍 interface. 구조화된 Nodes와 Property, Method를 갖는 Object로 문서 표현.</p><p>CSSOM ? JavaScript에서 CSS를 조작할 수 있는 API의 집합. HTML 대신 CSS가 대상인 DOM이라고 생각할 수 있음.</p></blockquote></ol><h3 id="render-tree를-사용하여-최종-웹-페이지-생성">Render Tree를 사용하여 최종 웹 페이지 생성</h3><ol><li><p>DOM과 CSSOM을 결합하여 Render Tree라는 트리 구조를 만든다.</p><p>렌더 트리는 visible 상태인 element들을 브라우저에 채우고 각 요소의 레이아웃을 계산하고 그리기 위해 필요한 스타일 및 콘텐츠 정보를 포함한다.</p><li><p>렌더 트리를 사용해서 각 요소의 위치를 계산한다.</p><li><p>계산된 위치에 맞게 사용자가 볼 수 있도록 화면에 요소를 추가하거나 그린다.</p></ol><h2 id="그래서-ssr-이-뭔데-">그래서 SSR 이 뭔데 ?</h2><p>렌더링의 정의가 단순하게 생각해서, 서버가 HTML 파일들을 클라이언트에 제공하면 그걸 그리는 프로세스인데 .</p><p>SSR에서 말하는 렌더링 정의는 이 것과 다른 것 같다.</p><p>SSR에서 말하는 렌더링은 CSR의 반대 개념으로 이해하는 것이 좋은데. 한마디로 HTML 이 사용자의 눈에 페이지가 들어오기 까지 필요한 레이아웃과 로직들의 정의라고 한다면 이러한 정의를 작성하는 행위를 말한다. (즉, HTML을 작성하는 것). SSR은 그 행위를 서버가 하겠다는 뜻이다.</p><blockquote><h3 id="html은-내가-작성하는거-아니냐고-">HTML은 내가 작성하는거 아니냐고 ?</h3><p>html 파일을 정적으로 그려서 단순히 웹페이지에 게시하였을 때는 그럴 수 있다.</p><p>그러나 시대가 바뀌고 웹 기술 수준이 높아지면서 정적인 컨텐츠를 제공하던 웹페이지들이 사용자의 입력에 따라 동적으로 특정 영역만 변경하거나, 어디에도 정의되어 있지 않은 완전히 새로운 화면을 보여주어야 하는 경우도 생겼다.</p><p>그래서 HTML의 내용을 직접 작성하지 않고 javascript 언어로 동적으로 작성&amp;변경하는 로직이 나타나게 됐다. (Ajax, jquery 등)</p></blockquote><p><strong>서버사이드 렌더링</strong>(일명 SSR)은 서버가 클라이언트에게 HTML 파일을 전달할 때 완전히 내용이 구성된 HTML 페이지로 변환하는 기능이라고 한다.</p><p>말이 너무 어렵다.</p><p>쉽게 말해서 이 말은 브라우저가 렌더링(HTML -&gt; 사용자 눈) 작업을 안한다는 뜻이 아니고. CSR의 반대 개념으로 기존의 static한 HTML파일을 전송하겠다는 뜻이다.</p><p>즉, SSR 은 새롭게 생긴 개념이 아니라, 전통적인 static한 웹 페이지를 제공하는 방법이다.</p><p>가장 처음 단순한 문서를 인터넷을 통해 제공할 때, 서버는 접속 url에 따라 static한 html파일을 클라이언트에게 제공했다.</p><p>그러나 정적인 텍스트들을 제공하던 웹페이지들이 점차 발전하면서 사용자에게 제공하는 화면과 입출력들이 복잡해지고(무거워지고) 화면변경 횟수가 늘어남에 따라 서버에 화면을 새로 요청해야하는 횟수가 동시에 늘어났다. 웹 서비스를 제공하기 위해 서버의 부하가 커지게 된 것이다. (사용자가 버튼을 누를 때 마다 완전히 새로운 페이지를 불러와야했다.)</p><p>게다가 화면을 새로고칠 때 마다 화면이 깜빡이는 flickering Issue도 유저경험에는 좋지 못했다.</p><p>그 때 CSR(Client Side Rendering)이 도입되었다. ajax 등이 나오면서 클라이언트는 서버로부터 항상 전체 페이지를 불러오지 않고 json과 같은 정보 데이터를 가져와서 js를 통해 동적으로 html 문서를 작성한다는 개념이다. 쉽게 말하면 클라이언트의 브라우저가 js를 읽고 동작시켜서 html 문서를 작성한다고 이해하면 될 것이다.</p><p>결론적으로 SSR은 원래 html 파일을 서버가 제공하던 방식인데. CSR 개념이 도입되면서 javascript를 통해 동적으로 페이지를 클라이언트가 그리게 되었고.</p><p>그 반대 개념으로 다시 SSR이란 용어가 대두된 것이다. CSR이 없었다면 SSR이란 말도 없었을 것이다. 왜냐면 그것이 당연한거 였으니까.</p><p>그러나, SSR이 옛날에 제공했던 static html 페이지와 다른 것은 서버측에서 미리 정의해둔 html을 단순히 넘겨주는 것이 아니라, CSR 처럼 프로그래밍 언어를 통해 동적으로 새로운 html 파일을 작성할 수 있기 때문에 용어가 붙여진 것 같다. (서버쪽에서 렌더링 한다 !)</p><h3 id="csr과-ssr의-동작차이">CSR과 SSR의 동작차이</h3><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-proofer-ignore data-src="/img/2021-09-16_4.39.43.png" alt="2021-09-16_4.39.43" /><tbody><tr><td style="text-align: center">상 SSR 하 CSR</table></div><p>싱글페이지 어플리케이션은 화면을 그리는 주체가 클라이언트기 때문에 서버로부터는 이후 화면에 들어갈 데이터만 심플하게 json 데이터로 넘겨받는다.</p><p>즉, 클라이언트 사이드 렌더링은 <strong>html 파일은 깡통으로 불러오고 다른 페이지들을 그릴 수 있는 로직과 정보가 담긴 js를 다운로드해 클라이언트 측에서 js를 통해 화면을 그리고</strong>.</p><p>서버 사이드 렌더링은 <strong>html파일에 사용자가 컨텐츠를 보기위한 모든 정보가 담긴 채로 파일을 받아서 바로 렌더링 한다.</strong></p><blockquote><p>***js를 안 받는 것은 아니다 ! 화면을 만드는 것과 관련된 js가 아닐 뿐이다. 서버사이드 렌더링도 html파일에 동작과 관련된 js파일이 존재한다면 추가적으로 서버에 js파일 제공을 요청한다.</p></blockquote><p>코드로 비교해보자.</p><p>다음은 크롬 개발자도구로 확인한 현재 블로그 한 페이지의 html 데이터이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-proofer-ignore data-src="/img/2021-09-16_3.45.22.png" alt="2021-09-16_3.45.22" /><tbody><tr><td style="text-align: center">SSR</table></div><p>body 태그에 li, a, span 태그 및 텍스트들이 모두 존재하고있다. 브라우저는 해당 html파일을 받아서 그리기만 하면 바로 사용자에게 화면을 제공할 수 있을 것이다.</p><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-proofer-ignore data-src="/img/2021-09-16_3.49.50-1784404.png" alt="2021-09-16_3.49.50" /><tbody><tr><td style="text-align: center">CSR</table></div><p>반면에 CSR 의 html을 상당히 심플하다. body 태그 내부에 어떠한 데이터도 없고. 앱의 시작점인 app.js 요청하고 해당 .js 파일부터 시작해 필요에 따라 모든 페이지를 동적으로 작성한다.</p><p>즉 , app.js 부터 파생된 일련의 javascript 로직들이 동작해서 html 문서를 만들기 전까지 사용자는 아무런 화면도 조회할 수 없다. 왜냐면 그것이 .. csr이니까.</p><h2 id="ssr-서버-사이드-렌더링-vs-csr-클라이언트-사이드-렌더링">SSR (서버 사이드 렌더링) vs CSR (클라이언트 사이드 렌더링)</h2><p>그렇다면 CSR과 SSR은 왜 달라야 하는 것이고(?) 두 렌더링 방식의 차이는 왜 존재하는 것인가 ..</p><p>먼저 <strong>CSR</strong>은 SPA(Single Page Application)와 같이 인터랙션이 많은 동적인 페이지를 구성해야할 때 유리하다.</p><p>사용자 눈에 보이게되는 HTML을 그리는 주체가 클라이언트고 그리는 도구도 클라이언트가 가지고 있기 때문에 클라이언트의 액션이나 상황에 따라 동적으로 페이지를 구현하기에 유리하다. 게다가 데이터에 따라 특정 작은 영역만 화면을 변경할 때도 서버로 부터 전체 html을 불러올 필요없이 변경에 필요한 데이터만 받아와서 클라이언트가 변경 적용할 수 있으므로 서버에 대한 부담을 줄여줄 수 있다.</p><p>반면에 <strong>SSR</strong>은 HTML을 만들어서 사용자에게 제공하기 때문에 (동적으로 그릴 경우에도) 각 요청마다 새롭게 그린 전체 HTML파일을 클라이언트에게 계속 전송하여야 한다. 즉, 하나의 인터랙션에 전송하는 HTML크기가 크다는 것을 의미한다. 변경이 필요없고 중복된 데이터도 모두 포함하여 보내주어야 하기 때문이다. 그러나 화면을 그리기위한 많은 js 파일을 보내주지 않아도 된다는 것은 강점이다.</p><hr /><h3 id="그럼-csr이-더-좋은거-아닙니까">그럼 CSR이 더 좋은거 아닙니까?</h3><p>반드시 그렇지는 않다. 각 방식은 장단점이 존재한다.</p><p><strong>CSR</strong></p><ul><li>장점 1. 초기 로딩 이후에 특정 페이지로의 이동, 컨텐츠의 변경작업 등 인터랙션에 대한 처리 속도가 빠르다. (필요한 데이터만 가져오기 때문)<li>장점 2. 특정 영역만 클라이언트가 재구성할 수 있기 때문에 페이지 전환이나 데이터 변경시에 깜빡임 이슈가 없다.<li><p>장점 3. 페이지가 로드되면 바로 상호작용 할 수 있다. ( TTV = TTI )</p><li>단점1. 초기 로딩 속도가 느리다. (서버로 부터 깡통 html 파일을 받고 화면을 그리기위한 js를 받은 다음 이를 동작시켜야 비로소 화면을 그릴 수 있다. 이 작업이 끝날 때 까지 사용자는 흰색 화면만 봐야한다.) <em>그러나 요즘 기기 성능이 점점 좋아지면서 큰 의미는 없어진 것 같다.</em><li>단점2. 검색엔진 최적화(<em>Search Engine Optimization</em>, SEO) 에 불리하다. 구글 같이 js내용을 읽을 수 있는 똑똑한 검색엔진이 아니면 일반적인 크롤러는 html 파일밖에 참고하지 못하는데 html파일은 깡통이기 때문에 검색엔진은 빈 페이지로 인식한다. 즉 검색 결과 상단에 노출될 수 없다..)</ul><p><strong>SSR</strong></p><ul><li>장점 1. 사용자가 처음 페이지 컨텐츠를 보는데까지 걸리는 시간이 적다. (초기로딩이 빠르다.)<li><p>장점 2. SEO에 유리하다. (CSR 단점과 반대)</p><li>단점 1. 초기 로딩 이후의 단순 변경은 느리다. (서버가 전체 페이지를 그려야하기 때문에)<li>단점 2. 서버 부하가 증가한다. (html을 만드는게 서버이기 때문에)<li>단점 3. (정적 페이지가 아니라면) 컨텐츠를 보는것과 상호작용이 가능한 시간이 다르다. (상호작용을 위해 .js 파일이 필요하다면 클라이언트는 추가적으로 파일을 요청할 것이고 그것이 모두 실행되기 전까지는 상호작용 할 수 없다. TTV != TTI )</ul><blockquote><p>TTV : Time to View (볼 수 있는 시간)</p><p>TTI : Time to Interact (상호작용 가능한 시간)</p></blockquote><div class="table-wrapper"><table><thead><tr><th style="text-align: center"><img data-proofer-ignore data-src="/img/1_jJkEQpgZ8waQ5P-W5lhxuQ-1784075.png" alt="1_jJkEQpgZ8waQ5P-W5lhxuQ" /><tbody><tr><td style="text-align: center"><img data-proofer-ignore data-src="/img/1_CRiH0hUGoS3aoZaIY4H2yg-1784129.png" alt="1_CRiH0hUGoS3aoZaIY4H2yg" /><tr><td style="text-align: center">SSR과 CSR의 TTV, TTI : https://www.omnisci.com/technical-glossary/server-side-rendering</table></div><h3 id="어떻게-하면-잘-쓸-수-있나요">어떻게 하면 잘 쓸 수 있나요</h3><p>위와 같이 각 방식의 장단점이 뚜렷하기 때문에 두 렌더링 방식 중 반드시 하나를 선택해야 하는 것은 아니다.</p><p>동적인 인터랙션이 많은 페이지는 CSR로 , 정적인 컨텐츠가 많은 페이지는 SSR로 구현할 수 있고.</p><p>게다가 빌드 타임에 어플리케이션을 실행하여 초기 상태를 정적 HTMl로 캡쳐하여 파일을 만들어서 SEO에 조금 더 유리해질 수 있는 Prerendering 기법이나</p><p>서버에서 렌더링 한 HTML의 돔 트리와 데이터를 재사용하도록 하는 Rehydration 등의 기법도 존재한다. (물론 뭐든지 비용이 든다)</p><p>따라서 구동 방식에 대해 이해를 하고, 어떤 방식이 어떤 환경에서 좋을지 고민해야한다.</p><p><strong>CSR</strong>은 가장 큰 단점이 페이지를 그리고 상호작용하기 위해 많은 .js파일을 요구하고 그 것에 따라 초기 로딩 속도가 느려지는 것이기 때문에 반드시 필요한 영역에 필요한 js 만을 요구할 수 있도록 고려되어야 하고</p><p><strong>SSR</strong>은 어떻게 하면 서버에서 렌더링하는 시간과 TTV 와 TTI 의 시간차를 단축시킬지를 고민하자.</p><h2 id="references"><em>References</em></h2><p>https://developers.google.com/web/updates/2019/02/rendering-on-the-web?hl=ko</p><p>https://www.seobility.net/en/wiki/Rendering</p><p>https://www.omnisci.com/technical-glossary/server-side-rendering</p><p>https://medium.com/walmartglobaltech/the-benefits-of-server-side-rendering-over-client-side-rendering-5d07ff2cefe8</p></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/frontend/'>Frontend</a>, <a href='/categories/web/'>Web</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/ssr/" class="post-tag no-text-decoration" >SSR</a> <a href="/tags/csr/" class="post-tag no-text-decoration" >CSR</a> <a href="/tags/server-side-rendering/" class="post-tag no-text-decoration" >SERVER SIDE RENDERING</a> <a href="/tags/client-side-rendering/" class="post-tag no-text-decoration" >CLIENT SIDE RENDERING</a> <a href="/tags/rendering/" class="post-tag no-text-decoration" >Rendering</a> <a href="/tags/%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81/" class="post-tag no-text-decoration" >서버사이드 렌더링</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"></div><div class="share-wrapper"> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=[Web] SSR(서버사이드 렌더링)이 대체 뭐야? - 머리속에 다 있어요&url=/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=[Web] SSR(서버사이드 렌더링)이 대체 뭐야? - 머리속에 다 있어요&u=/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=[Web] SSR(서버사이드 렌더링)이 대체 뭐야? - 머리속에 다 있어요&url=/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink('', '')" data-toggle="tooltip" data-placement="top" title=""> </i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/posts/Web-SSR(%EC%84%9C%EB%B2%84%EC%82%AC%EC%9D%B4%EB%93%9C-%EB%A0%8C%EB%8D%94%EB%A7%81)%EC%9D%B4-%EB%8C%80%EC%B2%B4-%EB%AD%90%EC%95%BC/">[Web] SSR(서버사이드 렌더링)이 대체 뭐야?</a><li><a href="/posts/%EC%9C%84%EB%8C%80%ED%95%9C-%EC%97%AC%EC%A0%95%EC%9D%98-%EC%8B%9C%EC%9E%91/">위대한 여정의 시작</a><li><a href="/posts/Postgresql-%ED%8A%B8%EB%A6%AC%EA%B1%B0%EB%A5%BC-%EB%B0%B0%EC%9B%8C%EB%B3%B4%EC%9E%90/">[postgresql] 트리거를 배워보자</a><li><a href="/posts/Node.js-Express-%ED%94%84%EB%A0%88%EC%9E%84%EC%9B%8C%ED%81%AC-%EC%84%A4%EC%B9%98/">[node.js] express 프레임워크 설치</a><li><a href="/posts/%EB%A9%94%ED%83%80%EB%B2%84%EC%8A%A4%EC%97%90-%EB%8C%80%ED%95%9C-%EC%83%9D%EA%B0%81/">메타버스에 대한 생각</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/express/">express</a> <a class="post-tag" href="/tags/node-js/">Node.js</a> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/client-side-rendering/">CLIENT SIDE RENDERING</a> <a class="post-tag" href="/tags/cookie-parser/">cookie-parser</a> <a class="post-tag" href="/tags/csr/">CSR</a> <a class="post-tag" href="/tags/dotenv/">dotenv</a> <a class="post-tag" href="/tags/end-point/">end-point</a> <a class="post-tag" href="/tags/extends/">extends</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/posts/node.js-sequelize(%EC%8B%9C%ED%80%84%EB%9D%BC%EC%9D%B4%EC%A6%88)%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-RDB%EC%99%80-%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0/"><div class="card-body"> <span class="timeago small" >Sep 8<i class="unloaded">2021-09-08T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[node.js] sequelize(시퀄라이즈)를 사용해서 rdb와 통신하기</h3><div class="text-muted small"><p> Api 서버를 구축하고자 할 때 DB와의 연결은 필수적이라고 할 수 있다. 오늘은 시퀄라이즈 라이브러리를 사용해서 DB와 연결하고 CRUD 기능을 수행해보자. 시퀄라이즈 ? 다양한 RDB와 호환되는 ORM(Object Relational Mapping) 라이브러리. (ex. maria, postgre, sqlite, mssql .. ) ...</p></div></div></a></div><div class="card"> <a href="/posts/210907-%EC%9D%BC%EA%B8%B0/"><div class="card-body"> <span class="timeago small" >Sep 7<i class="unloaded">2021-09-07T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>210907 일기</h3><div class="text-muted small"><p> 아직 모르는게 산더미고 배워야할 것도 엄청 많은데. 진도가 잘 안나가는 것 같아 고민이다 ! 글을 하나 작성하는데 굉장히 긴 시간이 걸리는데, 요즘은 글을 잘 쓰기 위해 고민하는 시간이 학습하는 시간보다 많아질 것 같아 걱정이 된다. 하다보면 요령이 생기겠지 ? 그래도 블로그를 시작하기 전 까지는 모르는것을 찾을 때, 다른 블로그를 참고하거나 s...</p></div></div></a></div><div class="card"> <a href="/posts/Node.js-Express-Router%EC%99%80-REST-API-%EC%97%94%EB%93%9C%ED%8F%AC%EC%9D%B8%ED%8A%B8-%EB%84%A4%EC%9D%B4%EB%B0%8D-%EA%B7%9C%EC%B9%99/"><div class="card-body"> <span class="timeago small" >Sep 5<i class="unloaded">2021-09-05T00:00:00+09:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>[node.js] express router와 rest api 엔드포인트 네이밍 규칙</h3><div class="text-muted small"><p> Express의 endpoint path들을 구조적으로 관리하기 위한 Router를 알아보도록 하자. route : 길, Router : 길 찾는 놈. 아마 Router 를 배우기 전이라면 app.js 안에 수 없이 많은 api 가 존재할 것이다. end-point 의 종류도 다양할 것이고. 어느정도 규모가 큰 시스템(사실 그렇게 크지 않...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/posts/node.js-sequelize(%EC%8B%9C%ED%80%84%EB%9D%BC%EC%9D%B4%EC%A6%88)%EB%A5%BC-%EC%82%AC%EC%9A%A9%ED%95%B4%EC%84%9C-RDB%EC%99%80-%ED%86%B5%EC%8B%A0%ED%95%98%EA%B8%B0/" class="btn btn-outline-primary" prompt="previous"><p>[node.js] sequelize(시퀄라이즈)를 사용해서 rdb와 통신하기</p></a> <span class="btn btn-outline-primary disabled" prompt="next"><p>-</p></span></div></div></div></div><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2021 <a href="https://github.com/jaeone94">Jaeone94</a>.</p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/express/">express</a> <a class="post-tag" href="/tags/node-js/">Node.js</a> <a class="post-tag" href="/tags/api/">api</a> <a class="post-tag" href="/tags/db/">db</a> <a class="post-tag" href="/tags/client-side-rendering/">CLIENT SIDE RENDERING</a> <a class="post-tag" href="/tags/cookie-parser/">cookie parser</a> <a class="post-tag" href="/tags/csr/">CSR</a> <a class="post-tag" href="/tags/dotenv/">dotenv</a> <a class="post-tag" href="/tags/end-point/">end point</a> <a class="post-tag" href="/tags/extends/">extends</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script> <script src="https://cdn.jsdelivr.net/combine/npm/lozad/dist/lozad.min.js,npm/magnific-popup@1/dist/jquery.magnific-popup.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.16.1,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id="></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', ''); }); </script>
